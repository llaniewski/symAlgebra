// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/symAlgebra.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// sS
sSymbol sS(Rcpp::String v);
static SEXP symAlgebra_sS_try(SEXP vSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< Rcpp::String >::type v(vSEXP );
        sSymbol __result = sS(v);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sS(SEXP vSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sS_try(vSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sN
sSymbol sN(double v);
static SEXP symAlgebra_sN_try(SEXP vSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< double >::type v(vSEXP );
        sSymbol __result = sN(v);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sN(SEXP vSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sN_try(vSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sSymboloperator_plus
sSymbol sSymboloperator_plus(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sSymboloperator_plus_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sSymboloperator_plus(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sSymboloperator_plus(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sSymboloperator_plus_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sSymboloperator_minus
sSymbol sSymboloperator_minus(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sSymboloperator_minus_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sSymboloperator_minus(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sSymboloperator_minus(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sSymboloperator_minus_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sSymboloperator_times
sSymbol sSymboloperator_times(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sSymboloperator_times_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sSymboloperator_times(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sSymboloperator_times(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sSymboloperator_times_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sSymboloperator_divide
sSymbol sSymboloperator_divide(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sSymboloperator_divide_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sSymboloperator_divide(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sSymboloperator_divide(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sSymboloperator_divide_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sSymboloperator_power
sSymbol sSymboloperator_power(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sSymboloperator_power_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sSymboloperator_power(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sSymboloperator_power(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sSymboloperator_power_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sSymboloperator_equal
bool sSymboloperator_equal(sSymbol& x, sSymbol& y);
static SEXP symAlgebra_sSymboloperator_equal_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< sSymbol& >::type y(ySEXP );
        bool __result = sSymboloperator_equal(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sSymboloperator_equal(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sSymboloperator_equal_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}

// validate (ensure exported C++ functions exist before calling them)
static int symAlgebra_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("sSymbol(*sS)(Rcpp::String)");
        signatures.insert("sSymbol(*sN)(double)");
        signatures.insert("sSymbol(*sSymboloperator_plus)(const sSymbol&,const sSymbol&)");
        signatures.insert("sSymbol(*sSymboloperator_minus)(const sSymbol&,const sSymbol&)");
        signatures.insert("sSymbol(*sSymboloperator_times)(const sSymbol&,const sSymbol&)");
        signatures.insert("sSymbol(*sSymboloperator_divide)(const sSymbol&,const sSymbol&)");
        signatures.insert("sSymbol(*sSymboloperator_power)(const sSymbol&,const sSymbol&)");
        signatures.insert("bool(*sSymboloperator_equal)(sSymbol&,sSymbol&)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP symAlgebra_RcppExport_registerCCallable() { 
    R_RegisterCCallable("symAlgebra", "symAlgebra_sS", (DL_FUNC)symAlgebra_sS_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sN", (DL_FUNC)symAlgebra_sN_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sSymboloperator_plus", (DL_FUNC)symAlgebra_sSymboloperator_plus_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sSymboloperator_minus", (DL_FUNC)symAlgebra_sSymboloperator_minus_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sSymboloperator_times", (DL_FUNC)symAlgebra_sSymboloperator_times_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sSymboloperator_divide", (DL_FUNC)symAlgebra_sSymboloperator_divide_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sSymboloperator_power", (DL_FUNC)symAlgebra_sSymboloperator_power_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sSymboloperator_equal", (DL_FUNC)symAlgebra_sSymboloperator_equal_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_RcppExport_validate", (DL_FUNC)symAlgebra_RcppExport_validate);
    return R_NilValue;
}
